\chapter{Extended Logical Structures}

The aim of this section is to construct from a given contextual category $\sfC$
with extra structure another contextual category $\sfC^{\cxt}$ with the same
structure, but where objects are iterated context extensions, compatibly with a
canonical contextual functor $\sfC\hookrightarrow\sfC^{\cxt}$ defining an
equivalence on the underlying categories, thereby
generalizing our structures from simple context extensions to arbitrary ones.
Indeed, we may then take a context extension, look at it in $\sfC^{\cxt}$, apply
the construction and then carry it back through the equivalence. This extension
shall be heavily exploited in the final part of the thesis. This technique has
been mentioned multiple times in the literature to justify various results at a
certain level of generality, however nobody actually carried out the necessary
constructions.

\section{Constructions}

On the type theoretical side, extensions of logical rules for $\Ids$-types to
contexts were first explored by Streicher \cite{Str93}, then by Gambino and
Garner \cite{GG08} under the name of \emph{identity contexts}, also called
$\Ids$-contexts.

\begin{notation}
  We shall make use of their notation \cite[4]{GG08} in the second part of this
  section and the final chapter of this thesis to study $\Syn{\T}$, meaning that
  we abbreviate the sequence of judgements
  \[\Gamma\vdash A_1\type,\]
  \[\Gamma,a_1:A_1\vdash A_2(a_1)\type,\]
  \[\vdots\]
  \[\Gamma,a_1:A_1,\ldots,a_{n-1}:A_{n-1}(a_1,\ldots,a_{n-2})\vdash
  A_n(a_1,\ldots,a_{n-1})\type\]
  by
  \[\Gamma\vdash\Delta\context,\]
  in which case $\Delta$ is a \emph{dependent context} in context $\Gamma$ and
  we shall write that $\Delta=A_1,\ldots,A_n$ as a shorthand.
  Similarly,
  \[\Gamma\vdash x:\Delta\]
  abbreviates
  \[\Gamma\vdash a_1:A_1,\]
  \[\Gamma,a_1:A_1\vdash a_2:A_2(a_1),\]
  \[\vdots\]
  \[\Gamma,a_1:A_1,\ldots,a_{n-1}:A_{n-1}(a_1,\ldots,a_{n-2})\vdash
  a_n:A_n(a_1,\ldots,a_{n-1})\]
  and then $x$ is a \emph{dependent term} of $\Delta$ in context $\Gamma$, which
  can be thought of as a tuple $(a_1,\ldots,a_n)$. Then,
  \[\Gamma,x:\Delta\vdash\Theta(x)\context\]
  specifies the dependency of $\Theta$ on the term $x:\Delta$ in context
  $\Gamma$.

  \noindent
  It is also possible to introduce further expressions, like
  \[\Gamma\vdash \Delta\equiv\Theta\context\]
  for judgmental equality between dependent contexts and
  \[\Gamma\vdash x\equiv x':\Delta,\]
  for judgmental equality between dependent terms, defined as pointwise
  judgmental equalities. The details are straightforward and therefore omitted.
\end{notation}
\noindent

Lumsdaine claimed that it is possible to provide extensions of the logical
structures we are studying in \cite[26]{Lum10}. At the
time Kapulkin proved the theorem this thesis focuses on,
nothing further was available in the literature and only later him and
Lumsdaine gave more details on these matters \cite{KL18}. In this section we aim
to partially fix that for $\Pis$-structures specifically, which will be the main
contribution of this work. It should be noted that, imitating Gambino and
Garner, we may derive the
corresponding logical rules for what would then be called $\Pis$-contexts,
however we will not do so and focus on the semantics, believing that the
translation should be straightforward and a simple duplication of work.

We begin by constructing the category of iterated contexts, where we
will extend the structures.

\begin{construction}\cite[21]{Lum10}
  Given a contextual category $\sfC$, we construct a contextual category
  $\sfC^{\cxt}$ in the following way:
  \begin{enumerate}
    \item the set $\Ob_n\sfC^{\cxt}$ is given by $n$-iterated non-trivial context
      extensions
      \[\Gamma_1.\Gamma_2.\ldots.\Gamma_n\]
      in $\sfC$;
    \item morphisms
      $\Gamma_1.\Gamma_2.\ldots.\Gamma_n\rightarrow\Delta_1.\Delta_2.\ldots.\Delta_m$
      are morphisms between them seen as objects of $\sfC$;
    \item $*$ is the only element of $\Ob_0\sfC^{\cxt}$;
    \item
      $\cft(\Gamma_1.\Gamma_2.\ldots.\Gamma_n.\Gamma_{n+1})=\Gamma_1.\Gamma_2.\ldots.\Gamma_n$;
    \item the map $p_{\Gamma_1.\Gamma_2.\ldots.\Gamma_n.\Gamma_{n+1}}\colon
      \Gamma_1.\Gamma_2.\ldots.\Gamma_{n+1}\rightarrow
      \Gamma_1.\Gamma_2.\ldots.\Gamma_n$ is the dependent projection exhibiting
      $\Gamma_1.\Gamma_2.\ldots.\Gamma_{n+1}$ as a context extension of
      $\Gamma_1.\Gamma_2.\ldots.\Gamma_n$;
    \item the chosen pullbacks are given by iterating the pullbacks along the
      basic dependent projections, as in the original contextual category.
  \end{enumerate}

  As we can see, any object of $\sfC^{\cxt}$ either is the empty context or is
  isomorphic to one in
  $\Ob_1\sfC^{\cxt}$, that is the one which we get by looking at the associated object
  in $\sfC$ and then taking the dependent projection from it to the terminal
  object, which exhibits it as a 1-iterated context extension. The isomorphism
  is then given by the map in $\sfC^{\cxt}$ corresponding to the identity of the
  object in $\sfC$. We now specify a monad $\sfC\mapsto\sfC^{\cxt}$ on $\Cxl$.

  The unit $\sfC\rightarrow\sfC^{\cxt}$ sends every $n$-object in $\sfC$ to
  the corresponding $n$-iterated (simple) context extension and every morphism
  to the one it represents.

  Before we construct the multiplication, let's study this contextual functor.
  Every $n$-iterated
  context in $\sfC^{\cxt}$ is isomorphic to one in the image of the unit, namely
  the one which we get by reducing it to an iterated simple context extension,
  meaning that the functor is essentially surjective. Also, it is fully faithful
  by construction and therefore it defines an equivalence on the underlying
  categories.

  Let's construct the multiplication. An $n$-object of $(\sfC^{\cxt})^{\cxt}$ is an
  $n$-iterated context extension where each extension is itself an iterated
  context extension in $\sfC$, that is
  \[(\Gamma_1.\ldots.\Gamma_{i_1}).(\Gamma_{i_1+1}.\ldots.\Gamma_{i_2}).\ldots.(\Gamma_{i_{n-1}+1}.\ldots.\Gamma_{i_n}).\]
  Since composing dependent projections gives dependent projections,
  seeing $\Gamma_{i_{j-1}+1}.\ldots.\Gamma_{i_j}$ as a single context extension
  $\Delta_j$ in $\sfC$, we can naturally
  map the object of $(\sfC^{\cxt})^{\cxt}$ to $\Delta_1.\ldots.\Delta_n$ in
  $\sfC^{\cxt}$ and, again, every morphism
  in $(\sfC^{\cxt})^{\cxt}$ corresponds to a unique one in $\sfC^{\cxt}$ once we
  specify domain and codomain. By construction, this functor is again contextual
  and an equivalence of categories.

  The monad axioms follow from the fact that, essentially, both unit and
  multiplication are ``identities'' on objects and morphisms.
\end{construction}

\begin{prop}
  The above construction defines a monad on $\Cxl$.
\end{prop}

We are now ready, given a contextual category $\sfC$, to extend the
$\Pis$-structure to $\sfC^{\cxt}$. We shall do so in two parts, first in full
generality and then under extra assumptions.

Given $\Gamma.\Delta.\Theta$ in $\sfC^{\cxt}$, where
$l(\Gamma.\Delta.\Theta)=l(\Gamma.\Delta)+n=l(\Gamma)+m+n$ in $\sfC$, we
build $\Gamma.\Pis(\Delta,\Theta)$ by induction on the length of the context
extensions involved, taking the
one from $\sfC$ in case we are working with objects corresponding to simple
extensions.

\begin{construction}[Part 1]
  If $n=0$, then
  \begin{align*}
    \Gamma.\Pis(\Delta,\Theta) &=\Gamma, \\
    \app_{\Delta,\Theta} &=1_{\Gamma.\Delta}, \\
    \lambda_{\Delta,\Theta}(b) &=1_\Gamma.
  \end{align*}
  Notice that the only possible $b$ in the latter case is given by
  $1_{\Gamma.\Theta}$. This is not really necessary to specify the
  $\Pis$-structure, however we shall need it later in Lemma \ref{radj}.

  We now work with the case where $m>0$, $n=1$, thus we can write
  $\Gamma.\Delta.\Theta=\Gamma.\Delta.B$. In the base case, $m=1$, we have
  $\Gamma.\Delta=\Gamma.A$ and therefore have to simply set our structure to
  coincide with the one in $\sfC$.

  If $n-1>0$, we have
  $\Gamma.\Delta=\Gamma.\Delta'.A$ and then set
  \begin{align*}
    \Gamma.\Pis(\Delta,B)
    &=\Gamma.\Pis(\Delta'.A,B)=\Gamma.\Pi(\Delta',\Pi(A,B)) \\
    \app_{\Delta,B} 
    &\colon
    \Gamma.\Pis(\Delta',\Pi(A,B)).\Delta'.A
                    \xrightarrow{q(\app_{\Delta',\Pis(A,B)},p^*_{\Pi(A,B)}A)} \\
    &\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad
    \Gamma.\Delta'.\Pi(A,B).A
    \xrightarrow{\app_{A,B}}
    \Gamma.\Delta'.A.B \\
    \lambda_{\Delta,B}(b)
    &\colon
    \Gamma
    \xrightarrow{\lambda_{\Delta',\Pis(A,B)}(\lambda_{A,B}(b))}
    \Gamma.\Pis(\Delta',\Pi(A,B)).
  \end{align*}
  The idea here is to replicate the adjunction $\Set(A\times
  B,C)\cong\Set(A,\Set(B,C))$. The map $\app_{\Delta,B}$ is then naturally
  interpreted as a sequence of partial evaluations and the phenomenon is
  commonly known as \emph{currying-uncurrying}.

\end{construction}

  We have fully specified the construction for
  $l(\Gamma.\Delta.\Theta)=l(\Gamma.\Delta)+1$ in $\sfC$, hence we shall move on
  to the case where $\Delta$ has arbitrary length and construct the necessary
  structure by inducting on the length of $\Theta$.

We will do so for syntactic categories and in contextual categories where a
section $c\colon\Gamma\rightarrow\Gamma.A.B$ can be split as
two sections $a\colon\Gamma\rightarrow\Gamma.A$,
$b\colon\Gamma.A\rightarrow\Gamma.A.B$.
We see that $p_B\cdot c=p_B\cdot b\cdot a=a$. Syntactically, this means that if
we pick two terms $a:A$, $b:B(a)$ over $\Gamma$ at once, then we can also
specify for each choice of a term $a':A$ over $\Gamma$ a term $b':B(a')$ such
that $b\equiv b'$ when $a\equiv a'$. We later point out the
difficulties encountered without our assumption and exploit our previously
presented notation for extended type-theoretic rules to reason about
$\Syn{T}^{\cxt}$ as if we were working with $\Syn{T}$.

\begin{construction}[Part 2]
  Suppose that
  $l(\Gamma.\Delta.\Theta)=l(\Gamma.\Delta)+n$, $n>1$, and we have already
  provided the relevant constructions up to $n-1$. We again decompose
  the context as $\Gamma.\Delta.\Theta'.B$.

  If we are working with a contextual category $\sfC$ where sections split, we
  make use of our assumption on
  $y\colon\Gamma.\Delta\rightarrow\Gamma.\Delta.\Theta'.B$ to get $b\cdot y'$.
  \begin{align*}
    \Gamma.\Pis(\Delta,\Theta)
    &=\Gamma.\Pis(\Delta,\Theta'.B)=\Gamma.\Pi(\Delta,\app^*_{\Delta,\Theta'}B) \\
    \app_{\Delta,\Theta}
    &\colon\Gamma.\Pis(\Delta,\Theta').\Pi(\Delta,\app^*_{\Delta,\Theta'}B).\Delta
    \xrightarrow{\app_{\Delta,\app^*_{\Delta,\Theta'}B}} \\
    &\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad
    \Gamma.\Pis(\Delta,\Theta').\Delta.\app^*_{\Delta,\Theta'}B
    \xrightarrow{q(\app_{\Delta,\Theta'},B)} \\
    &\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad
    \Gamma.\Delta.\Theta'.B \\
    \lambda_{\Delta,\Theta}(y)
    &\colon\Gamma
    \xrightarrow{\lambda_{\Delta,\Theta'}(y')}
    \Gamma.\Pis(\Delta,\Theta')
    \xrightarrow{\lambda_{p^*_{\Pis(\Delta,\Theta')}\Delta,\app^*_{\Delta,\Theta'}B}(\app_{\Delta,\Theta'}^*b')}
    \Gamma.\Pis(\Delta,\Theta').\Pi(\Delta,\app^*_{\Delta,\Theta'}B)
  \end{align*}

  If we are instead in $\Syn{T}$, we can define $\lambda_{\Delta,\Theta}(y)$ in
  the following way: from $y':\Theta(x),b:B(x,y')$ in context $\Gamma,x:\Delta$
  we can indeed simply take the section specified
  by $\lambda(x:\Delta).y(x):\Pis(\Delta,\Theta)$ that is the pair
  \[\lambda(x:\Delta).y'(x):\Pis(\Delta,\Theta'),\]
  \[\lambda(x:\Delta).b'(x,y'(x)):\Pis(x:\Delta,B(\app(\lambda(x:\Delta).y'(x),x))),\]
  where we have made explicit the dependencies of the type $B$.

Finally, given $a\colon\Gamma\rightarrow\Gamma.\Delta$,
$f\colon\Gamma.\Delta\rightarrow\Gamma.\Delta.\Theta$, we construct
$\app_{\Delta,\Theta}(f,a)$ as in the definition of $\Pis$-structures.
\end{construction}


This fully specifies the data needed for a $\Pis$-structure on $\sfC^{\cxt}$,
however we still have to check that it is indeed one, which we will do in the
next section. First, however, we sketch the extension for $\Sigmas$-structures
by assuming to have a left inverse $\unpair_{A,B}$
of $\pair_{A,B}$ for any context $\Gamma.A.B$. Such a left inverse can be
constructed in $\Syn{T}$ by looking at the projection maps described in
\cite[Sec.\ 1.6]{Uni13}.

\begin{construction}
  Let $\sfC$ be a contextual category with a $\Sigmas$-structure. Given a
  dependent context $p_\Delta\colon\Gamma.\Delta.\Theta\rightarrow\Gamma.\Delta$
  with $l(\Gamma.\Delta.\Theta)=l(\Gamma.\Delta)+n=l(\Gamma)+m+n$ in $\sfC$ we
  proceed by induction on $m,n>0$.

  Let's fix $m=1$. If $n=1$, like for $\Pis$-structures we are forced to take
  the definition from $\sfC$, so we can focus on $n>1$. We have then
  $\Gamma.\Delta.\Theta=\Gamma.\Delta.\Theta'.B$, so we take
  \begin{align*}
    \Gamma.\Sigmas(\Delta,\Theta)
    &=\Gamma.\Sigmas(\Delta,\Theta'.B)
    =\Gamma.\Sigmas(\Delta,\Sigmas(\Theta',B)) \\
    \pair_{\Delta,\Theta}
    &\colon
    \Gamma.\Delta.\Theta'.B
    \xrightarrow{\pair_{\Theta',B}}
    \Gamma.\Delta.\Sigmas(\Theta',B)
    \xrightarrow{\pair_{\Delta,\Sigmas(\Theta',B)}}
    \Gamma.\Sigmas(\Delta,\Sigmas(\Theta',B)),
  \end{align*}
  however we are still missing for all maps
  $z\colon\Gamma.\Delta.\Theta\rightarrow\Gamma.\Sigmas(\Delta,\Theta).\Psi$
  such that $p_\Psi\cdot z=\pair_{\Delta,\Theta}$ a section
  $\csplit_z\colon\Gamma\Sigmas(\Delta,\Theta)
  \rightarrow\Gamma.\Sigmas(\Delta,\Theta).\Psi$ satisfying
  $\csplit_z\cdot\pair_{\Delta,\Theta}=z$. This will be done using
  $\unpair_{\Delta,\Theta}$, which is constructed like $\pair_{\Delta,\Theta}$.
\end{construction}

\begin{construction}
  Let $\sfC$ be a contextual category with an $\Ids$-structure. Given a dependent
  context $p_\Delta\colon\Gamma.\Delta\rightarrow\Gamma$ with
  $l(\Gamma.\Delta)=l(\Gamma)+n$ in $\sfC$ we proceed by induction on $n>0$.

  If $n=1$,
  \begin{align*}
    \Gamma.\Ids_A &=\Gamma.\Ids_A, \\
    r_A &=r_A, \\
    J_{\Theta,C,d} &=J(\Theta,C,d),
  \end{align*}
  where the objects on the right are the ones given by the $\Ids$-structure on
  $\sfC$.

  If $n>1$, assuming to have extended the $\Ids$-structure to shorter context
  extensions in $\sfC$, we write instead
  \begin{align*}
    \Gamma.\Ids_{\Delta} &=\Gamma.\Ids_{\Delta'.A}=\Gamma.\Ids_{\Delta'}.\Ids_A \\
    r_{\Delta} &= q(,)\cdot r_A
  \end{align*}
\end{construction}


\section{Properties}

In this section we verify that the desired properties hold.

\begin{prop}
  Given a contextual category with a $\Pis$-structure $\sfC$, the above data
  defines a $\Pis$-structure on $\sfC^{\cxt}$ which is compatible with the natural
  contextual functor $\sfC\rightarrow\sfC^{\cxt}$.
\end{prop}
\begin{proof}
  We have to
  show that it is a $\Pis$-structure, which we will do inductively by verifying
  that at every step our proposed construction maintains the desired properties.
  The compatibility with the contextual functor will then follow directly from
  the way we defined the base case.

  Let's consider an object $\Gamma.\Delta.\Theta$ in $\sfC^{\cxt}$ such that
  $l(\Gamma.\Delta.\Theta)=l(\Gamma.\Delta)+n=l(\Gamma)+m+n$ in $\sfC$. The only
  interesting case is the one where $m,n>0$ and at least one of them is
  $>1$: indeed, the desired properties in the other cases are either
  trivial or follow directly from the fact that they hold in $\sfC$.

  We start as before by working on $m>1$, $n=1$, so we write
  $\Gamma.\Delta.\Theta=\Gamma.\Delta.B=\Gamma.\Delta'.A.B$ and assume that
  the desired properties hold for shorter context extensions.
  We can then write
  \begin{align*}
    p_B\cdot\app_{\Delta,B}
    &=p_B\cdot
    \app_{A,B}\cdot
    q(\app_{\Delta',\Pis(A,B)},p^*_{\Pi(A,B)}A) \\
    &=q(p_{\Pis(A,B)},A)\cdot
    q(\app_{\Delta',\Pis(A,B)},p^*_{\Pi(A,B)}A) \\
    &=q(p_{\Pis(A,B)}\cdot\app_{\Delta',\Pi(A,B)},A) \\
    &=q(q(p_{\Pis(\Delta',\Pi(A,B))},\Delta'),A) \\
    &=q(p_{\Pis(\Delta',\Pi(A,B))},\Delta'.A) \\
    &=q(p_{\Pis(\Delta,B)},\Delta) \\
    p_B\cdot\app_{\Delta,B}(f,a)
    &=p_B\cdot
    \app_{\Pis(\Delta,B)}\cdot
    (f,a) \\
    &=q(p_{\Pis(\Delta,B)},\Delta)\cdot
    (f,a) \\
    &=a \\
    p_{\Pis(\Delta,B)}\cdot\lambda_{\Delta,B}(b)
    &=p_{\Pis(\Delta',\Pi(A,B))}\cdot
    \lambda_{\Delta',\Pis(A,B)}(\lambda_{A,B}(b)) \\
    &=1_\Gamma.
  \end{align*}
  \wfd{PLEASE VERIFY, LIKELY WRONG}
  To justify $\app_{\Delta,B}(\lambda_{\Delta,B}(b),y)=b\cdot y$ we shall use
  type-theoretic reasoning. The section
  $b\colon\Gamma.\Delta\rightarrow\Gamma.\Delta.B$ is
  such that\[y\equiv (y',a)\mapsto(y',a,b(y',a))\equiv(y,b(y)),\] thus
  applying $\lambda_{A,B}$ and then $\lambda_{\Delta',\Pis(A,B)}$ we get
  $\lambda(y':\Delta').(\lambda(a:A).b(y',a))\equiv\lambda(y:\Delta).b(y)$.
  Also, $\app_{\Delta,B}$ acts type-theoretically as
  \begin{align*}
    (f,y) \\
    ^{\text{split } y}&\equiv(f,y',a) \\
    ^{q(\app_{\Delta',\Pis(A,B)},p^*_{\Pi(A,B)}A)}&\mapsto
    (y',\app(f,y'),a) \\
    ^{\app_{A,B}}&\mapsto
    (y',a,\app(\app(f,y'),a)) \\
    &\equiv(y,\app(f,y)),
  \end{align*}
  thus in this case we get
  \begin{align*}
    (\lambda(y:\Delta).b(y),y) \\
    &\equiv(\lambda(y':\Delta').(\lambda(a:A).b(y',a)),y',a) \\
    &\mapsto
    (y',\lambda(a:A).b(y',a),a) \\
    &\mapsto
    (y',a,b(y',a)) \\
    &\equiv(y,b(y)),
  \end{align*}
  where the inductive hypothesis has been used in the second step. Notice that
  we used the hypothesis about splitting sections, which was unnecessary in the
  corresponding part of the construction.
  
  We now check inductively on the length of $\Theta$.
  \begin{align*}
    p_{\Theta}\cdot\app_{\Delta,\Theta}
    &=p_{\Theta'}\cdot
    p_B\cdot
    q(\app_{\Delta,\Theta'},B)\cdot
    \app_{\Delta,\app^*_{\Delta,\Theta'}B} \\
    &=p_{\Theta'}\cdot
    \app_{\Delta,\Theta'}\cdot
    p_{\app^*_{\Delta,\Theta'}B}\cdot
    \app_{\Delta,\app^*_{\Delta,\Theta'}B} \\
    &=q(p_{\Pis(\Delta,\Theta)},\Delta)\cdot
    q(p_{\Pis(\Delta,\app^*_{\Delta,\Theta'}B)},\Delta) \\
    &=q(p_{\Pis(\Delta,\Theta')}\cdot
    p_{\Pis(\Delta,\app^*_{\Delta,\Theta'}B)},\Delta) \\
    &=q(p_{\Pis(\Delta,\Theta').\Pi(\Delta,\app^*_{\Delta,\Theta'}B)},\Delta) \\
    &=q(p_{\Pis(\Delta,\Theta)},\Delta) \\
    p_\Theta\cdot\app_{\Delta,\Theta}(f,a)
    &=p_\Theta\cdot\app_{\Delta,\Theta}\cdot(a,f) \\
    &=q(p_{\Pis(\Delta,\Theta)},\Delta)\cdot(a,f) \\
    &=a \\
    p_{\Pis(\Delta,\Theta)}\cdot
    \lambda_{\Delta,\Theta}(b)
    &=p_{\Pis(\Delta,\Theta')}\cdot
    p_{\Pis(p_{\Pi(\Delta,\Theta')}^*\Delta,\app^*_{\Delta,\Theta'}B')}\cdot
    \lambda_{p^*_{\Pis(\Delta,\Theta')}\Delta,\app^*_{\Delta,\Theta'}B}(\app_{\Delta,\Theta'}^*b'')\cdot
    \lambda_{\Delta,\Theta'}(b') \\
    &=p_{\Pis(\Delta,\Theta')}\cdot
    \lambda_{\Delta,\Theta'}(b') \\
    &=1_\Gamma.
  \end{align*}
  Again, to justify
  $\app_{\Delta,\Theta}(\lambda(b),y)=b\cdot y$ we use internal reasoning.
  We know that, given a factorization $b=b''\cdot b'$, $b$ acts as
  \[y\mapsto(y,b(y))\equiv(y,b'(y),b''(y,b'(y))),\]
  thus our construction provides us with
  \[\lambda(y:\Delta).b(y)\equiv
  (\lambda(y:\Delta).b'(y),\lambda(y:\Delta).b''(y,b'(y))).\]
  Also, $\app_{\Delta,\Theta}$ acts internally as
  \begin{align*}
    (f,y) \\
    ^{\text{split }f}&\equiv(f',f'',y) \\
    ^{\app_{\Delta,\app^*_{\Delta,\Theta'}B}}&\mapsto(f',y,\app(f'',y)) \\
    ^{q(\app_{\Delta,\Theta'},B)}&\mapsto(y,\app(f',y),\app(f'',y)) \\
    &\equiv(y,\app(f,y)),
  \end{align*}
  which here translates to
  \begin{align*}
    (\lambda(y:\Delta).b(y),y) \\
    &\equiv(\lambda(y:\Delta).b'(y),\lambda(y:\Delta).b''(y,b'(y)),y) \\
    &\mapsto(\lambda(y:\Delta).b'(y),y,b''(y,b'(y))) \\
    &\mapsto(y,b'(y),b''(y,b'(y))) \\
    &\equiv(y,b(y)),
  \end{align*}
  where the inductive hypothesis has been used in the second step.

  To conclude the proof one would still need to verify that the construction is
  compatible with context substitution.
\end{proof}


We shall also need the following lemma.

\begin{lem}[\cite{Kap17}]\label{piequal}
  Given an iterated context extension $\Gamma.\Delta.\Theta.\Psi$ in a
  contextual category with $\Pis$-types $\sfC$, the contexts
  \[\Gamma.\Pis(\Delta,\Theta.\Psi),\quad\Gamma.\Pis(\Delta,\Theta).\Pis(p^*_{\Pis(\Delta,\Theta)}\Delta,\app^*_{\Delta,\Theta}\Psi)\]
  are equal in $\sfC$. Also,
  $\Gamma.\Pis(\Delta,p_{\Psi})=p_{\Pis(\Delta,\app^*_{\Delta,\Theta}\Psi)}$.
\end{lem}
\begin{proof}
  For the first claim, it is enough to notice that the two contexts reduce to
  the same one in $\sfC$ after applying the inductive construction we defined on
  $\sfC^{\cxt}$ to reduce $\Psi$.

  For the second claim instead we consider the chain of equalities
  \begin{align*}
    \Gamma.\Pis(\Delta,p_{\Psi})
    &=q(p_{\Pis(\Delta,\Theta.\Psi)},\Pis(\Delta,\Theta))\cdot
    \lambda_{\Delta,\Theta}(1_{p^*_{\Pis(\Delta,\Theta)}\Delta},p_\Psi\cdot\app_{\Delta,\Theta.\Psi}) \\
    &=p_{\Pis(\Delta,\app^*_{\Delta,\Theta}\Psi)}\cdot
    p_{\Pis(\Delta,\Theta)}\cdot
    \lambda_{\Delta,\Theta}(1_{p^*_{\Pis(\Delta,\Theta)}\Delta},p_\Psi\cdot\app_{\Delta,\Theta.\Psi}) \\
    &=p_{\Pis(\Delta,\app^*_{\Delta,\Theta}\Psi)}.
  \end{align*}
  \wfd{(PLEASE CHECK)}
\end{proof}


\begin{prop}\cite[Prop.\ 3.3.1]{Gar09b}
  Given a contextual category with an $\Ids$-structure $\sfC$, $\sfC^{\cxt}$ also
  carries a natural $\Ids$-structure compatible with the contextual functor
  $\sfC\rightarrow\sfC^{\cxt}$ as described in REFS 0808.
\end{prop}

\begin{lem}\cite[Lemma 2.28]{1808}
  Given a contextual category with $\Ids$, $\Pies$ structures and function
  extensionality $\sfC$, the latter can also be extended to $\sfC^{\cxt}$
  compatibly with the extended $\Ids$ and $\Pis$ structures.
\end{lem}

%\begin{cor}\cite[Lemma 2.29]{1808}
%  Under the conditions of the previous theorem, if
%  $f\colon\Gamma.\Delta.\Theta\rightarrow\Gamma.\Delta.\Psi$ is
%  bi-invertible over $\Gamma.\Delta$, then the same goes for the induced map
%  $\Gamma.\Pis(\Delta,\Theta)\rightarrow\Gamma.\Pi(\Delta,\Psi)$.
%\end{cor}

\begin{rmk}
  Lumsdaine noted that the lift of $\Ids$ and $\Pis$
  structures is not compatible with the monad we provided earlier because they
  are not compatible with the multiplication. On the other
  hand, with a strategy along the line of the one we presented for
  $\Pis$-structures we can also lift $\Sigmas$-structures compatibly with the
  monad, meaning that $(-)^{\cxt}$ restricts to one on $\Cxl_{\Sigmas}$.
\end{rmk}
